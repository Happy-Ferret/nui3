/*
  NUI3 - C++ cross-platform GUI framework for OpenGL based applications
  Copyright (C) 2002-2003 Sebastien Metrot

  licence: see nui3/LICENCE.TXT
*/


#include "nui.h"
#include "nglThread.h"
#include "nglCriticalSection.h"

std::map<nglThread::ID,nglThread*> nglGlobalThreadMap;
nglCriticalSection nglGlobalThreadMapCS(_T("nglThread_nglGlobalThreadMapCS"));

const nglString& nglThread::GetName() const
{
  return mName;
}

void nglThread::SetAutoDelete(bool set)
{
  mAutoDelete = set;
}

bool nglThread::GetAutoDelete() const
{
  return mAutoDelete;
}


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// GetThreadFromGlobalList
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//	Get thread from list
//
nglThread* nglGetThreadFromGlobalList(nglThread::ID threadID)  
{
  nglCriticalSectionGuard	guard(nglGlobalThreadMapCS);
  std::map<nglThread::ID,nglThread*>::const_iterator it = nglGlobalThreadMap.find(threadID);
  if (it == nglGlobalThreadMap.end())
    return NULL;
  return (it->second);
}



///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// AddThreadInGlobalList
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//	Add a thread in list
//
void nglAddThreadInGlobalList(nglThread* thread)
{
  nglCriticalSectionGuard	guard(nglGlobalThreadMapCS);
  nglGlobalThreadMap[thread->GetID()] = thread;
}


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// DelThreadFromGlobalList
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Delete a thread from list
//
bool nglDelThreadFromGlobalList(nglThread* thread)
{
  nglCriticalSectionGuard	guard(nglGlobalThreadMapCS);
  return (nglGlobalThreadMap.erase(thread->GetID()) != 0);
}


////////////////////////
// nglThreadDelegate
////////////////////////
nglThreadDelegate::nglThreadDelegate(const ThreadDelegate& rStartFunction, Priority priority)
: nglThread(priority), mDelegate(rStartFunction)
{
}

nglThreadDelegate::nglThreadDelegate(const ThreadDelegate& rStartFunction, const nglString& rName, Priority priority)
: nglThread(rName, priority), mDelegate(rStartFunction)
{
}

nglThreadDelegate::~nglThreadDelegate()
{
}

void nglThreadDelegate::OnStart()
{
  mDelegate();
}
